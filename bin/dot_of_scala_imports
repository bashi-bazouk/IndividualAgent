#!/usr/bin/python

import re
import sys
import os
import os.path as path
from os.path import abspath

class Main():

  def main(self):

    subtree = os.getcwd()
    if len(sys.argv) > 1:
      abspath(sys.argv[1])

    if path.isdir(subtree):
      # subtree is valid!

      imports = [(file, self.imports_of_file(file)) for file in self.scala_files(subtree)]
      for (file, lines) in imports:
        print file.split("/")[-1][0:-6]
        for line in lines:
          print "  %s" % self.target(line)

    else:
      print "%s is not a valid subtree" % subtree

  def scala_files(self, subtree):
    acc = []
    def visit(arg, dirname, names):
      acc.extend([dirname + "/" + f for f in names if f.endswith(".scala")])
    path.walk(subtree, visit, None)
    return acc

  def imports_of_file(self, file):
    id = "((_[a-zA-Z0-9_]+) | ([a-zA-Z0-9][a-zA-Z0-9_]*))"
    ext = "((\._) | (\.\{[^}]*\}))"
    pattern = re.compile("\s*import\s((\.%s)*)%s?\n" % (id,ext))

    acc = []
    with open(file, 'r') as file:
      for line in file.readlines():
        match = pattern.match(line)
        if match:
          name = match.group(1)
          if name.endswith("._"):
            acc.append(name[0:-2])
          else:
            acc.append(name)
    return acc
    
  def target(self, line):
    return line

  def toposort2(data):
    from functools import reduce

    # Ignore self dependencies.
    for k, v in data.items():
        v.discard(k)
    # Find all items that don't depend on anything.
    extra_items_in_deps = reduce(set.union, data.itervalues()) - set(data.iterkeys())
    # Add empty dependences where needed
    data.update({item:set() for item in extra_items_in_deps})
    while True:
        ordered = set(item for item, dep in data.iteritems() if not dep)
        if not ordered:
            break
        yield ordered
        data = {item: (dep - ordered)
                for item, dep in data.iteritems()
                    if item not in ordered}
    assert not data, "Cyclic dependencies exist among these items:\n%s" % '\n'.join(repr(x) for x in data.iteritems())

Main().main()
