#!/usr/bin/python
from os import listdir, path, stat
import sys
import subprocess

## Here are some utility functions ##

# general
class IAException(Exception):
  pass

def error(msg):
  raise IAException(msg)

def sh(command, **kwargs):
  return subprocess.call(command.split(" "), **kwargs)

def prefix(name):
  return "--prefix=%s/" % name

def assert_clean():
  tmp = "/tmp/check_git"
  with open(tmp, 'w+') as stdout:
    sh("git diff --exit-code", stdout=stdout)
    if stat(tmp)[6] != 0:
      # file is non-empty -> changes need to be committed
      error("Commit files before using this command.")

def quick_commit(*args):
  sh("git add -A")
  if len(args) is 0:
    sh("""git commit -m "quickcommit""")
  else:
    sh("git commit -m \"%s\"" % args.join(" "))

# remotes
def remotes():
  return [f for f in listdir(".git/refs/remotes/") if not path.isfile(".git/refs/remotes/%s" % f)]

def assert_remote_exists(name):
  if not name in remotes():
    error("remote %s does not exist" % name)

def assert_remote_does_not_exist(name):
  if name in remotes():
    error("remote %s already exists" % name)

# sub_branches
def current_branch():
  return open(".git/HEAD").read().strip().split("/")[-1]

def sub_branches():
  return [f for f in listdir(".git/refs/heads/") if f.startswith("ia_")]

def sub_branch_exists(name, sub_branch):
  return "ia_%s_%s" % (name, sub_branch) in sub_branches()

def assert_sub_branch_exists(name, sub_branch):
  if not sub_branch_exists(name, sub_branch):
    error("branch %s_%s does not exist" % (name, sub_branch))

def assert_sub_branch_does_not_exist(name, sub_branch):
  if sub_branch_exists(name, sub_branch):
    error("branch %s_%s already exists" % (name, sub_branch))

def create_or_update_sub_branch(name, sub_branch):
  branch = current_branch()
  if sub_branch_exists(name, sub_branch):
    sh("git checkout ia_%s_%s" % (name, sub_branch))
    sh("git pull")
  else:
    sh("git checkout -b ia_%s_%s %s/%s" % (name, sub_branch, name, sub_branch))
  sh("git checkout %s" % branch)

def remove_sub_branch(name, sub_branch):
  assert_sub_branch_exists(name, sub_branch)
  sh("git branch -D ia_%s_%s" % (name, sub_branch))

# subtrees

def assert_subtree_exists(name):
  if not path.exists(name):
    error("subtree %s does not exist" % name)

def assert_subtree_does_not_exist(name):
  if path.exists(name):
    error("subtree %s already exists" % name)

def sub_branches_of_subtree(name):
  return [f for f in sub_branches() if f.startswith("ia_%s" % name)]

def map_sub_branch_of_subtree(name, clv):
  sub_branches = sub_branches_of_subtree(name)
  if clv is None and len(sub_branches) is 1:
    sub_branches[0]
  else:
    clv

## Here are the handlers ##

def add_project(name, url):
  print "ia add project %s %s" % (name, url)
  assert_remote_does_not_exist(name)
  sh("git remote add -f %s %s" % (name, url))

def remove_project(name):
  print "ia remove project %s" % (name)
  assert_remote_exists(name)
  sh("git remote rm %s" % name)
  sh("rm -r .git/refs/remotes/%s" % name)
  for b in sub_branches_of_subtree(name):
    sh("git branch -D %s" % b)
  remove_subtree(name)

def add_subtree(name, sub_branch="master"):
  print "ia add subtree %s %s" % (name, sub_branch)
  assert_remote_exists(name)
  assert_clean()
  # assert_subtree_does_not_exist(name)
  create_or_update_sub_branch(name, sub_branch)
  sh("git read-tree --prefix=%s -u ia_%s_%s" % (name, name, sub_branch))

def remove_subtree(name):
  print "ia remove subtree %s" % name
  if path.exists(name):
    sh("rm -r %s" % name)
    sh("git rm -r %s" % name)
     
def pull_subtree(name, sub_branch=None):
  print "ia pull subtree %s" % name
  assert_clean()
  assert_subtree_exists(name)
  sub_branch = map_sub_branch_of_subtree(name, sub_branch)
  if sub_branch is None:
    print "Usage: ia pull subtree %s <sub_branch>" % name
  else:
    create_or_update_sub_branch(name, sub_branch)
    command = "git merge --squash -s subtree --no-commit ia_%s_%s"
    sh(command % (name, name, sub_branch))

def push_subtree(name, sub_branch=None):
  print "ia push subtree %s" % name    
  assert_clean()
  assert_subtree_exists(name)
  sub_branch = map_sub_branch_of_subtree(name, sub_branch)
  if sub_branch is None:
    print  "Usage: ia push subtree %s <sub_branch>" % name
  else:
    pass

## Here are the handler routes ##

commands = {
  'add': {
    'project': add_project,
    'subtree': add_subtree },
  'remove': {
    'project': remove_project,
    'subtree': remove_subtree },
  'pull': {
    'subtree': pull_subtree },
  'push': {
    'subtree': push_subtree },
  'qc': quick_commit

}

## Here is the processor ##

try:
  subcommand = commands
  index = 1
  #  Invariant: subcommand is a dictionary AND there exist more arguments
  while type(subcommand) is dict and index < len(sys.argv):
    subcommand = subcommand[sys.argv[index]]
    index += 1
  # ~Invariant: subcommand is not a dictionary OR there exist no more arguments

  if type(subcommand) is dict and index == len(sys.argv):
    # subcommand is a dictionary -> command is incomplete
    def pprint(item, indent="  "):
      if type(item) is dict:
        for key, value in item.iteritems():
          if type(value) is dict:
            print "%s%s:\n" % (indent, key)
            pprint(value, indent="  %s" % indent)
          else:
            print"%s%s\n" % (indent, key)

    print "Usage:"
    print " ".join(sys.argv[1:])
    pprint(subcommand)
  else:
    # subcommand is not a dictionary -> command is complete
    subcommand(*sys.argv[index:])  
except IAException as e:
  print "ERROR: %s" % e.args
