#!/usr/bin/python
from os import listdir, path
import sys
import subprocess

## Here are some utility functions ##

# general
def error(msg):
  raise Exception(msg)

def sh(command):
  return subprocess.call(command.split(" "))

def prefix(name):
  return "--prefix=%s/" % name

# remotes
def remotes():
  return [f for f in listdir(".git/refs/remotes/") if not path.isfile(".git/refs/remotes/%s" % f)]

def assert_remote_exists(name):
  if not name in remotes():
    error("remote %s does not exist" % name)

def assert_remote_does_not_exist(name):
  if name in remotes():
    error("remote %s already exists" % name)

# sub_branches
def current_branch():
  return open(".git/HEAD").read().strip().split("/")[-1]

def sub_branches():
  return [f for f in listdir(".git/refs/heads/") if f.startswith("ia_")]

def sub_branch_exists(name, sub_branch):
  "%s_%s" % (name, sub_branch) in sub_branches()

def assert_sub_branch_exists(name, sub_branch):
  if not sub_branch_exists(name, sub_branch):
    error("branch %s_%s does not exist" % (name, sub_branch))

def assert_sub_branch_does_not_exist(name, sub_branch):
  if sub_branch_exists(name, sub_branch):
    error("branch %s_%s already exists" % (name, sub_branch))

def create_or_update_sub_branch(name, sub_branch):
  branch = current_branch()
  if sub_branch_exists(name, sub_branch):
    sh("git checkout ia_%s_%s %s/%s" % (name, sub_branch, name, sub_branch))
    sh("git pull")
  else:
    sh("git checkout -b ia_%s_%s %s/%s" % (name, sub_branch, name, sub_branch))
  sh("git checkout %s" % branch)

def remove_sub_branch(name, sub_branch):
  assert_sub_branch_exists(name, sub_branch)
  sh("git branch -D ia_%s_%s" % (name, sub_branch))

## Here are the handlers ##

def add_project(name, url):
  print "ia add project %s %s" % (name, url)
  assert_remote_does_not_exist(name)
  sh("git remote add -f %s %s" % (name, url))

def remove_project(name):
  print "ia remove project %s" % (name)
  assert_remote_exists(name)
  sh("git remote rm %s" % name)
  sh("rm -r .git/refs/remotes/%s" % name)

def add_subtree(name_and_branch):
  print "ia add subtree %s" % name_and_branch
  [name, branch] = name_and_branch.split("/")
  assert_remote_exists(name)
  print name
  print branch
  create_or_update_sub_branch(name, branch)
  print "here"
  sh("git read-tree --prefix=%s -u ia_%s_%s" % (name, name, branch))

def remove_subtree(name):
  print "ia remove subtree %s" % name
  sh("rm -r %s" % name)
  

## Here are the handler routes ##

commands = {
  'add': {
    'project': add_project,
    'subtree': add_subtree },
  'remove': {
    'project': remove_project,
    'subtree': remove_subtree }
}

## Here is the processor ##

try:
  subcommand = commands
  index = 1
  #  Invariant: subcommand is a dictionary AND there exist more arguments
  while type(subcommand) is dict and index < len(sys.argv):
    subcommand = subcommand[sys.argv[index]]
    index += 1
  # ~Invariant: subcommand is not a dictionary OR there exist no more arguments

  if type(subcommand) is dict and index == len(sys.argv):
    # subcommand is a dictionary -> command is incomplete
    def pprint(item, indent="  "):
      if type(item) is dict:
        for key, value in item.iteritems():
          if type(value) is dict:
            print "%s%s:\n" % (indent, key)
            pprint(value, indent="  %s" % indent)
          else:
            print"%s%s\n" % (indent, key)

    print "Usage:"
    print " ".join(sys.argv[1:])
    pprint(subcommand)
  else:
    # subcommand is not a dictionary -> command is complete
    subcommand(*sys.argv[index:])  
except Exception as e:
  print "Error: %s" % e
