#!/usr/bin/python
from os import *
import sys
import subprocess

## Here are some utility functions ##

def error(msg):
  raise Exception(msg)

def sh(command):
  return subprocess.call(command.split(" "))

def prefix(name):
  return "--prefix=%s/" % name

def remotes():
  return [f for f in listdir(".git/refs/remotes/") if not path.isfile(".git/refs/remotes/%s" % f)]

def assert_remote_exists(name):
  if not name in remotes():
    error("remote %s does not exist" % name)

def assert_remote_does_not_exist(name):
  if name in remotes():
    error("remote %s already exists" % name)

def sub_branch_exists(name, sub_branch):
  pass

def assert_sub_branch_exists(name, sub_branch):
  pass

def assert_sub_branch_does_note_exist(name, sub_branch):
  pass

## Here are the handlers ##

def add_project(name, url):
  print "ia add project %s %s" % (name, url)
  assert_remote_does_not_exist(name)
  sh("git remote add -f %s %s" % (name, url))

def remove_project(name):
  print "ia remove project %s" % (name)
  assert_remote_exists(name)
  sh("git remote rm %s" % name)
  sh("rm -r .git/refs/remotes/%s" % name)

def add_subtree(name_and_branch):
  print "ia add subtree %s" % name_and_branch
  [name, branch] = name_and_branch.split("/")
  assert_remote_exists(name)

def remove_subtree(name):
  print "ia remove subtree %s" % name
  
  

## Here are the handler routes ##

commands = {
  'add': {
    'project': add_project,
    'subtree': add_subtree },
  'remove': {
    'project': remove_project,
    'subtree': remove_subtree }
}

## Here is the processor ##

try:
  subcommand = commands
  index = 1
  #  Invariant: subcommand is a dictionary AND there exist more arguments
  while type(subcommand) is dict and index < len(sys.argv):
    subcommand = subcommand[sys.argv[index]]
    index += 1
  # ~Invariant: subcommand is not a dictionary OR there exist no more arguments

  if type(subcommand) is dict and index == len(sys.argv):
    # subcommand is a dictionary -> command is incomplete
    def pprint(item, indent="  "):
      if type(item) is dict:
        for key, value in item.iteritems():
          if type(value) is dict:
            print "%s%s:\n" % (indent, key)
            pprint(value, indent="  %s" % indent)
          else:
            print"%s%s\n" % (indent, key)

    print "Usage:"
    print " ".join(sys.argv[1:])
    pprint(subcommand)
  else:
    # subcommand is not a dictionary -> command is complete
    subcommand(*sys.argv[index:])  
except Exception as e:
  print "Error: %s" % e
