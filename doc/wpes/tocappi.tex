% ------------------------------------------------------------------------
% AMS-LaTeX Paper ********************************************************
% ------------------------------------------------------------------------
% Submitted:      Dec 15 2003
% Final Version:  
% Accepted:       
% ------------------------------------------------------------------------
% This is a journal top-matter template file for use with AMS-LaTeX.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\documentclass{tran-l}
%\documentclass[twocolumn]{amsart}
\documentclass[]{amsart}
%\documentclass[]{llncs}

%\documentclass[]{prentcsmacro}

%\usepackage[active]{srcltx} % SRC Specials for DVI Searching
\usepackage{url}

% From Allen's stable.
\usepackage{bigpage}
\usepackage{bcprules}
%\usepackage{code}
\usepackage{amsfonts}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{caption}
\usepackage{multicol}
\usepackage{mathpartir}
\usepackage{listings}
\usepackage{mathtools}

% Double brackets
\newcommand{\ldb}{[\![}
\newcommand{\rdb}{]\!]}
\newcommand{\ldrb}{(\!(}
\newcommand{\rdrb}{)\!)}
\newcommand{\lliftb}{\langle\!|}
\newcommand{\rliftb}{|\!\rangle}
% \newcommand{\lpquote}{\langle}
% \newcommand{\rpquote}{\rangle}
% \newcommand{\lpquote}{\lceil}
% \newcommand{\rpquote}{\rceil}
\newcommand{\lpquote}{\ulcorner}
\newcommand{\rpquote}{\urcorner}
\newcommand{\newkw}{\nu}

% SYNTAX
\newcommand{\id}[1]{\texttt{#1}}
\newcommand{\none}{\emptyset}
\newcommand{\eps}{\epsilon}
\newcommand{\set}[1]{\{#1\}}
\newcommand{\rep}[2]{\id{\{$#1$,$#2$\}}}
\newcommand{\elt}[2]{\id{$#1$[$#2$]}}
\newcommand{\infinity}{$\infty$}

\newcommand{\pzero}{\mathbin{0}}
\newcommand{\seq}{\mathbin{\id{,}}}
\newcommand{\all}{\mathbin{\id{\&}}}
\newcommand{\choice}{\mathbin{\id{|}}}
\newcommand{\altern}{\mathbin{\id{+}}}
\newcommand{\juxtap}{\mathbin{\id{|}}}
%\newcommand{\concat}{\mathbin{.}}
\newcommand{\concat}{\Rightarrow}
\newcommand{\punify}{\mathbin{\id{:=:}}}
\newcommand{\fuse}{\mathbin{\id{=}}}
\newcommand{\scong}{\mathbin{\equiv}}
\newcommand{\nameeq}{\mathbin{\equiv_N}}
\newcommand{\alphaeq}{\mathbin{\equiv_{\alpha}}}
\newcommand{\names}[1]{\mathbin{\mathcal{N}(#1)}}
\newcommand{\freenames}[1]{\mathbin{\mathcal{FN}(#1)}}
\newcommand{\boundnames}[1]{\mathbin{\mathcal{BN}(#1)}}
%\newcommand{\lift}[2]{\texttt{lift} \; #1 \concat #2}
\newcommand{\binpar}[2]{#1 \juxtap #2}
\newcommand{\outputp}[2]{#1 ! ( * #2 )}
\newcommand{\prefix}[3]{#1 ? ( #2 ) \concat #3}
\newcommand{\lift}[2]{#1 ! ( #2 )}
%\newcommand{\quotep}[1]{\lpquote #1 \rpquote}
\newcommand{\quotep}[1]{@#1}
\newcommand{\dropn}[1]{*#1}

\newcommand{\newp}[2]{\id{(}\newkw \; #1 \id{)} #2}
\newcommand{\bangp}[1]{\int #1}
\newcommand{\xbangp}[2]{\int_{#2} #1}
\newcommand{\bangxp}[2]{\int^{#2} #1}

\newcommand{\substp}[2]{\id{\{} \quotep{#1} / \quotep{#2} \id{\}}}
\newcommand{\substn}[2]{\id{\{} #1 / #2 \id{\}}}

\newcommand{\psubstp}[2]{\widehat{\substp{#1}{#2}}}
\newcommand{\psubstn}[2]{\widehat{\substn{#1}{#2}}}

\newcommand{\applyp}[2]{#1 \langle #2 \rangle}
\newcommand{\absp}[2]{\id{(} #1 \id{)} #2}

\newcommand{\transitions}[3]{\mathbin{#1 \stackrel{#2}{\longrightarrow} #3}}
\newcommand{\meaningof}[1]{\ldb #1 \rdb}
\newcommand{\pmeaningof}[1]{\ldb #1 \rdb}
\newcommand{\nmeaningof}[1]{\ldrb #1 \rdrb}

\newcommand{\Proc}{\mathbin{Proc}}
\newcommand{\QProc}{\quotep{\mathbin{Proc}}}

\newcommand{\entailm}{\mathbin{\vdash_{\mathfrak m}}} %matching
\newcommand{\entailp}{\mathbin{\vdash_{\mathfrak p}}} %behavioral
\newcommand{\entailv}{\mathbin{\vdash_{\mathfrak v}}} %validation
\newcommand{\congd}{\mathbin{\equiv_{\mathfrak d}}}
\newcommand{\congs}{\mathbin{\equiv_{\mathfrak s}}}
\newcommand{\congp}{\mathbin{\equiv_{\mathfrak p}}}
%\newcommand{\defneqls}{:\!=}
\newcommand{\defneqls}{\coloneqq}
%\newcommand{\logequiv}{\mathbin{\leftrightarrow}}

\newcommand{\barb}[2]{\mathbin{#1 \downarrow_{#2}}}
\newcommand{\dbarb}[2]{\mathbin{#1 \Downarrow_{#2}}}

% From pi-duce paper
\newcommand{\red}{\rightarrow}
\newcommand{\wred}{\Rightarrow}
\newcommand{\redhat}{\hat{\longrightarrow}}
\newcommand{\lred}[1]{\stackrel{#1}{\longrightarrow}} %transitions
\newcommand{\wlred}[1]{\stackrel{#1}{\Longrightarrow}}

\newcommand{\opm}[2]{\overline{#1} [ #2 ]} % monadic
\newcommand{\ipm}[2]{{#1} ( #2 )} 
\newcommand{\ipmv}[2]{{#1} ( #2 )} % monadic
\newcommand{\parop}{\;|\;}		% parallel operator
\newcommand{\patmatch}[3]{#2 \in #3 \Rightarrow #1}
\newcommand{\sdot}{\, . \,}		% Space around '.'
\newcommand{\bang}{!\,}
%\newcommand{\fuse}[1]{\langle #1 \rangle}		
\newcommand{\fusion}[2]{#1 = #2} % fusion prefix/action
\newcommand{\rec}[2]{\mbox{\textsf{rec}} \, #1. \, #2}
\newcommand{\match}[2]{\mbox{\textsf{match}} \; #1 \; \mbox{\textsf{with}} \; #2}
\newcommand{\sep}{:}
\newcommand{\val}[2]{\mbox{\textsf{val}} \; #1 \; \mbox{\textsf{as}} \; #2}

\newcommand{\rel}[1]{\;{\mathcal #1}\;} %relation
\newcommand{\bisim}{\stackrel{.}{\sim}_b} %bisimilar
\newcommand{\wb}{\approx_b} %weak bisimilar
\newcommand{\bbisim}{\stackrel{\centerdot}{\sim}} %barbed bisimilar
\newcommand{\wbbisim}{\stackrel{\centerdot}{\approx}} %weak barbed bisimilar
\newcommand{\bxless}{\lesssim}	%expansion less (amssymb required)
\newcommand{\bxgtr}{\gtrsim}	%expansion greater (amssymb required)
\newcommand{\beq}{\sim}		%barbed congruent
\newcommand{\fwbeq}{\stackrel{\circ}{\approx}}	%weak barbed congruent
\newcommand{\wbeq}{\approx}	%weak barbed congruent
\newcommand{\sheq}{\simeq}	%symbolic hypereq
\newcommand{\wbc}{\approx_{cb}}

% End piduce contribution

% rho logic

\newcommand{\ptrue}{\mathbin{true}}
\newcommand{\psatisfies}[2]{#1 \models #2}
\newcommand{\pdropf}[1]{\rpquote #1 \lpquote}
\newcommand{\pquotep}[1]{\lpquote #1 \rpquote}
\newcommand{\plift}[2]{#1 ! ( #2 )}
\newcommand{\pprefix}[3]{\langle #1 ? #2 \rangle #3}
\newcommand{\pgfp}[2]{\textsf{rec} \; #1 \mathbin{.} #2}
\newcommand{\pquant}[3]{\forall #1 \mathbin{:} #2 \mathbin{.} #3}
\newcommand{\pquantuntyped}[2]{\forall #1 \mathbin{.} #2}
\newcommand{\riff}{\Leftrightarrow}

\newcommand{\PFormula}{\mathbin{PForm}}
\newcommand{\QFormula}{\mathbin{QForm}}
\newcommand{\PropVar}{\mathbin{\mathcal{V}}}

\newcommand{\typedby}{\mathbin{\:\colon}}
\newcommand{\mixedgroup}[1]{\id{mixed($#1$)}}
\newcommand{\cast}[2]{\id{CAST AS} \; #1 \; (#2)}
\newcommand{\bslsh}{\mathbin{\id{\\}}}
\newcommand{\bslshslsh}{\mathbin{\id{\\\\}}}
\newcommand{\fslsh}{\mathbin{\id{/}}}
\newcommand{\fslshslsh}{\mathbin{\id{//}}}
\newcommand{\bb}[1]{\mbox{#1}}
\newcommand{\bc}{\mathbin{\mathbf{::=}}}
\newcommand{\bm}{\mathbin{\mathbf\mid}}
\newcommand{\be}{\mathbin{=}}
\newcommand{\bd}{\mathbin{\buildrel {\rm \scriptscriptstyle def} \over \be}}
\newcommand{\category}[1]{\mbox{\bf #1}}

%GRAMMAR
\newlength{\ltext}
\newlength{\lmath}
\newlength{\cmath}
\newlength{\rmath}
\newlength{\rtext}

\settowidth{\ltext}{complex type name}
\settowidth{\lmath}{$xxx$}
\settowidth{\cmath}{$::=$}
\settowidth{\rmath}{\id{attributeGroup}}
\settowidth{\rtext}{repetition of $g$ between $m$ and $n$ times}

\newenvironment{grammar}{
  \[
  \begin{array}{l@{\quad}rcl@{\quad}l}
  \hspace{\ltext} & \hspace{\lmath} & \hspace{\cmath} & \hspace{\rmath} & \hspace{\rtext} \\
}{
  \end{array}\]
}

% Over-full v-boxes on even pages are due to the \v{c} in author's name
\vfuzz2pt % Don't report over-full v-boxes if over-edge is small

% THEOREM Environments ---------------------------------------------------
 \newtheorem{thm}{Theorem}[subsection]
 \newtheorem{cor}[thm]{Corollary}
 \newtheorem{lem}[thm]{Lemma}
 \newtheorem{prop}[thm]{Proposition}
 \theoremstyle{definition}
 \newtheorem{defn}[thm]{Definition}
 \theoremstyle{remark}
 \newtheorem{rem}[thm]{Remark}
 \newtheorem{example}[thm]{Example}
 \numberwithin{equation}{subsection}
% MATH -------------------------------------------------------------------
 \DeclareMathOperator{\RE}{Re}
 \DeclareMathOperator{\IM}{Im}
 \DeclareMathOperator{\ess}{ess}
 \newcommand{\veps}{\varepsilon}
 \newcommand{\To}{\longrightarrow}
 \newcommand{\h}{\mathcal{H}}
 \newcommand{\s}{\mathcal{S}}
 \newcommand{\A}{\mathcal{A}}
 \newcommand{\J}{\mathcal{J}}
 \newcommand{\M}{\mathcal{M}}
 \newcommand{\W}{\mathcal{W}}
 \newcommand{\X}{\mathcal{X}}
 \newcommand{\BOP}{\mathbf{B}}
 \newcommand{\BH}{\mathbf{B}(\mathcal{H})}
 \newcommand{\KH}{\mathcal{K}(\mathcal{H})}
 \newcommand{\Real}{\mathbb{R}}
 \newcommand{\Complex}{\mathbb{C}}
 \newcommand{\Field}{\mathbb{F}}
 \newcommand{\RPlus}{\Real^{+}}
 \newcommand{\Polar}{\mathcal{P}_{\s}}
 \newcommand{\Poly}{\mathcal{P}(E)}
 \newcommand{\EssD}{\mathcal{D}}
 \newcommand{\Lom}{\mathcal{L}}
 \newcommand{\States}{\mathcal{T}}
 \newcommand{\abs}[1]{\left\vert#1\right\vert}
% \newcommand{\set}[1]{\left\{#1\right\}}
%\newcommand{\seq}[1]{\left<#1\right>}
 \newcommand{\norm}[1]{\left\Vert#1\right\Vert}
 \newcommand{\essnorm}[1]{\norm{#1}_{\ess}}

%%% NAMES
\newcommand{\Names}{{\mathcal N}}
\newcommand{\Channels}{{\sf X}}
\newcommand{\Variables}{{\mathcal V}}
\newcommand{\Enames}{{\mathcal E}}
\newcommand{\Nonterminals}{{\mathcal S}}
\newcommand{\Pnames}{{\mathcal P}}
\newcommand{\Dnames}{{\mathcal D}}
\newcommand{\Types}{{\mathcal T}}

\newcommand{\fcalc}{fusion calculus}
\newcommand{\xcalc}{${\mathfrak x}$-calculus}
\newcommand{\lcalc}{$\lambda$-calculus}
\newcommand{\pic}{$\pi$-calculus}
\newcommand{\rhoc}{$\rho$-calculus}
\newcommand{\hcalc}{highwire calculus}
\newcommand{\dcalc}{data calculus}
%XML should be all caps, not small caps. --cb
%\newcommand{\xml}{\textsc{xml}}
\newcommand{\xml}{XML} 

\newcommand{\papertitle}{Policy as Types}
% use static date to preserve date of actual publication
 \newcommand{\paperversion}{Draft Version 0.1 - July 19, 2013}

\newenvironment{toc}
{
\begin{list}{}{
   \setlength{\leftmargin}{0.4in}
   \setlength{\rightmargin}{0.6in}
   \setlength{\parskip}{0pt}
 } \item }
{\end{list}}

\newenvironment{narrow}
{
\begin{list}{}{
   \setlength{\leftmargin}{0.4in}
   \setlength{\rightmargin}{0.6in}
 } \item }
{\end{list}}

%%% ----------------------------------------------------------------------
\begin{document}
%\lstset{language=erlang}
\lstset{language=}

%These margin values appear to be relative to the bigpage package settings. --cb
\setlength{\topmargin}{0in}
\setlength{\textheight}{8.5in}
\setlength{\parskip}{6pt}

%\title{\huge{\papertitle}}
\title{\papertitle}

\author{ L.G. Meredith }
%\author{ Mark Miller }
\author{ Mike Stay }

%\address{Systems Biology, Harvard Medical School, Boston, Massachussetts, USA}

%\email{lg_meredith@hms.harvard.edu}

%\thanks{This work was completed during a visiting appointment at the Department of Systems Biology, Harvard Medical School.}

%\subjclass{Primary 47A15; Secondary 46A32, 47D20}

\keywords{ object-capability, concurrency, message-passing, policy, types, Curry-Howard }

%\date{April 6, 2002.}

\dedicatory{}

%\commby{Daniel J. Rudolph}

%%% ----------------------------------------------------------------------

\begin{abstract}
\normalsize{ 

  Drossopoulou and Nolan \cite{Drossopoulou:2013:NCP:2489804.2489811}
  argue persuasively for the need for a means to express policy in
  object-capability-based systems. We investigate a practical means to
  realize their aim via the Curry-Howard isomorphism. Specifically, we
  investigate representing policy as types in a behavioral type system
  for the \rhoc, a reflective-higher order variant of the \pic.

}

\end{abstract}

\noindent
{\large \textbf{Submission to WPES}}\\
\rule{6.25in}{0.75pt}\\\\\\

%%% ----------------------------------------------------------------------
\maketitle
%%% ----------------------------------------------------------------------

% \begin{center}
% \paperversion\\
% \end{center}

% \begin{toc}
% \tableofcontents
% \end{toc}

% \newpage
% ------------------------------------------------------------------------

\section{Introduction}

The object-capability (ocap) security model grew out of the realization
that good object-oriented programming practice leads to good security properties.
Separation of duties leads to separation of authority; information hiding
leads to integrity; message passing leads to authorization; 
and dependency injection to authority injection.  An
ocap-secure programming language enforces these patterns; the only way an
object can modify any state but its own is by sending messages on the object
references it possesses.  Authority can then be denied simply by not providing
the relevant object reference. Ocap languages do not provide ambient, undeniable 
authority such as the global variables in JavaScript,
static mutable fields in Java and C\#, or allowing access to arbitrary objects
through pointer arithmetic as in C and C++.  

We would like a way to declare the authority that an object ought to
possess and then check whether the implementation matches the intent; that is,
we would like a language for declaring security policy.
Drossopoulou and Nolan \cite{Drossopoulou:2013:NCP:2489804.2489811} convincingly argue that none 
of the current specification methods adequately capture all of the capability 
policies required to support ocap systems.

The Curry-Howard isomorphism relates formal logic to type theory; it says 
that propositions are to types as proofs are to programs.  Hennessey-Milner
logic lets us treat the type of a concurrent process as an assertion that 
it belongs to a set of processes, all of which satisfy some property.  

In this paper, we show that a concurrent process calculus called \rhoc is
an ocap language and sketch a translation from a subset of JavaScript into
the calculus; we also demonstrate that the corresponding Hennessey-Milner
logic suffices to capture the key notion of deniability.

\subsection{Overview and contributions} 

Other approaches to policy. Curry-Howard. Contracts as types.

\subsubsection{Organization of the rest of the paper}

We introduce the calculus, then the logic. Armed with these we
illustrate translating a simple ocap example into the calculus. Then
we illustrate how we can reason about properties of the translated
program and from there move to interpreting policy, focusing on
deniability. Finally, we conclude with a discussion of some of the
limitations of the approach and how we might approach these in future
work.

%%% ----------------------------------------------------------------------

\section{The calculus}

Before giving the formal presentation of the calculus and logic where
we interpret ocap programs and policy, respectively, we begin with a
couple of examples that illustrate a design pattern used over and over
in this paper. The first is a mutable single-place cell for storing
and retrieving state.

% \begin{lstlisting}[mathescape]
% def $Cell( slot, state ) \Rightarrow$ {
%   new $( v )$ {
%     $v!( state )$
%     match {
%       $slot ? get( ret ) \Rightarrow$ { 
%         $v?( s ) \Rightarrow ret!( s )$
%         $Cell( slot, s )$
%       }
%       $slot ? set( s ) \Rightarrow$ {
%         $Cell( slot, s )$
%       }
%     }
%   }
% }
% \end{lstlisting}

\begin{lstlisting}[mathescape]
def $Cell( slot, state ) \Rightarrow$ {
  new $( v )$ {
    $v!( state )$
    match {
      $slot ? get( ret ) \Rightarrow$ {
        $v?( s ) \Rightarrow ret!( s )$
        $Cell( slot, s )$
      }
      $slot ? set( s ) \Rightarrow$ { $Cell( slot, s )$ }
    }
  }
}
\end{lstlisting}

% \begin{lstlisting}[mathescape]
% def $Cell( slot, state ) \Rightarrow$ {
%   new $( v )$ {
%     $v!( state )$
%     $slot ? get( ret ) \Rightarrow$ { $v?( s ) \Rightarrow ret!( s )$ | $Cell( slot, s )$ } $+$ $slot ? set( s ) \Rightarrow$ { $Cell( slot, s )$ }
%   }
% }
% \end{lstlisting}

We read this as saying that a $Cell$ is parametric in some (initial)
$state$ and a $slot$ for accessing and mutating the cell's state. A
$Cell$ allocates a private channel $v$ where it makes the initially
supplied $state$ available to its internal computations. If on the
channel $slot$ it receives a $get$ message containing a channel $ret$
indicating where to send the state of the cell, it accesses the
private channel $v$ and sends the value it received on to the $ret$
channel; then it resumes behaving as a $Cell$. Alternatively, if it
receives a $set$ message containing some new state $s$, it simply
continues as a $Cell$ instantiated with accessor $slot$ and state $s$.

Despite the fact that this example bears a striking resemblance to code
in any of a number of popular libraries, notably the {\tt AKKA}
library for the {\tt Scala} language, it is only a mildly sugared
form of the direct representation in our calculus. Notice also that
like modern application code, it exhibits encapsulation and separation
of implementation from API: a cell's internal access to
{\tt state} is kept in a private channel {\tt v} while
external access is through {\tt slot}. Another nice thing about
this design pattern is that it scales through composition: when
translating ocap examples expressed in {\tt ECMAScript} to \rhoc\
we will effectively treat the state of an object as a parallel
composition of cells comprising its state.

The second gadget is an immutable map.

\begin{lstlisting}[mathescape]
def $Map( slot1, state1, \ldots , slotN, stateN ) \Rightarrow$ {
  new $( v1, \ldots )$ {
    $v1!( state1 )$
    $\ldots$
    $vN!( stateN )$
    $slot1 ? get( ret ) \Rightarrow$ { 
      $v1?( x ) \Rightarrow ret!( x )$
      $Map( slot1, x, \ldots , slotN, stateN )$
    }
    $\ldots$
    $slotN ? get( ret ) \Rightarrow$ { 
      $vN?( x ) \Rightarrow ret!( x )$
      $Map( slot1, state1, \ldots , slotN, x )$
    }
  }
}
\end{lstlisting}

The design pattern for maps is related the the one for cells, but is
missing the capability to mutate the map. The code does not serve a
request to set any of the slots it contains.

With these two patterns in hand it will be much easier to treat the
examples. Moreover, as we will see in the sequel, even with these
basic patterns we can already reason about policy and the shape of the
reason about policy for these examples scales compositionally to
reasoning about application-level policy.

Now let's introduce the calculus and its logic.

\subsubsection{Notation}

We let ${P, Q, R}$ range over processes and ${x, y, z}$ range over names.

\begin{grammar}
\mbox{\rhoc}		& {M, N}		& \bc	& \pzero & \mbox{null process} \\
%				&					& \bm	& {x}{?}{A} & \mbox{input} \\
				&					& \bm	& {x}{?}{( y_1, \ldots, y_N )} \Rightarrow {P} & \mbox{input} \\
%				&					& \bm	& {x}{!}{C} & \mbox{output} \\
				&					& \bm	& {x}{!}{( Q_1, \ldots, Q_N )} & \mbox{output} \\
				&					& \bm	& {M}{+}{N} & \mbox{choice} \\
				& { P, Q }              & \bc			& M & \mbox{include guarded processes} \\                                
				&                        		& \bm	& {P} \juxtap {Q} & \mbox{parallel} \\                                
				&					& \bm	& {*}{x} & \mbox{dereference} \\
%                                & { A }                 & \bc   & {( y_1, \ldots, y_N )} \Rightarrow {P} & \mbox{abstraction} \\
%                                & { C }                 & \bc   & {( Q_1, \ldots, Q_N )} & \mbox{data} \\
				& {x, y}  		& \bc	& {@}{P} & \mbox{reference} \\
\end{grammar}

% \begin{mathpar}
%   \inferrule* [lab=IO: stop input output choice] {} {{M,N} \bc \pzero \;|\; x?A \;|\; x!C \;|\; M+N }
%   \and
%   \inferrule* [lab=agent: abstraction data] {} {{A} \bc ({x_1}, \ldots, {x_N}) \Rightarrow P \;| \; {(}{Q_1, \ldots, Q_N}{)}}
%   \and
%   \inferrule* [lab=process] {} {{P,Q} \bc M \;| \;P|Q \;|\; {*}{x}}
%   \and
%   \inferrule* [lab=name] {} {{x,y} \bc {@}{P}}
% \end{mathpar} 

The examples from the previous section use mild (and entirely
standard) syntactic sugar: \texttt{def} making recursive definitions a
little more convenient than their higher-order encodings, \texttt{new}
making fresh channel allocation a little more convenient and
\texttt{match} for purely input-guarded choice. Additionally, the
examples use line breaks, rather than $\binpar{}{}$ for parallel
composition. Thus the expression $v!( state )$ is actually a thread
running in parallel with the \texttt{match} expression in the $Cell$
definition. The interested reader is directed to the appendix for more
details.

\subsection{Free and bound names}

The syntax has been chosen so that a binding occurrence of a name is
sandwiched between round braces, ${(} \cdot {)}$. Thus, the
calculation of the free names of a process, $P$, denoted
$\freenames{P}$ is given recursively by

%\begin{multicols}{2}
%{
	\begin{eqnarray*}
		\freenames{\pzero} & \defneqls & \emptyset \\
%		\freenames{x \id{[}y\id{]}} & = & \{ x, y \} \\
		\freenames{{x}{?}{( y_1, \ldots, y_N )} \Rightarrow {P}} & \defneqls & \{ x \} \cup (\freenames{P} \setminus \{ y_1, \ldots y_N \}) \\
		\freenames{{x}{!}{( Q_1, \ldots, Q_N )}} & \defneqls & \{ x \} \cup \bigcup \freenames{Q_i} \\
		\freenames{\binpar{P}{Q}} & \defneqls & \freenames{P} \cup \freenames{Q} \\
		\freenames{{*}{x}} & \defneqls & \{ x \} \\
	\end{eqnarray*}
%}
%\end{multicols}

An occurrence of $x$ in a process $P$ is \textit{bound} if it is not
free. The set of names occurring in a process (bound or free) is
denoted by $\names{P}$.

\subsection{Structural congruence}

The {\em structural congruence} of processes, noted $\scong$, is the
least congruence containing $\alpha$-equivalence, $\alphaeq$, that
satisfies the following laws:

\begin{eqnarray*}
	{P} \juxtap \pzero	
		&  \scong \; {P} \; \scong & 
			\pzero \juxtap {P} \\
	{P} \juxtap {Q}	
		& \scong & 
			{Q} \juxtap {P} \\
	({P} \juxtap {Q}) \juxtap {R}
		& \scong & 
			{P} \juxtap ({Q} \juxtap {R}) \\
\end{eqnarray*}

\paragraph{Name equivalence} As discussed in
\cite{DBLP:conf/tgc/MeredithR05} name-equivalence is subtly
recursively related to $\alpha$-equivalence and structural equivalence.

\subsection{Syntactic substitution}

Now we build the substitution used by $\alpha$-equivalence. We use
$\Proc$ for the set of processes, $\QProc$ for the set of names, and
${\{}{y_1} / {x_1}, \ldots, {y_n} / {x_n}{\}}$ to denote partial maps, $s : \QProc
\rightarrow \QProc$. A map, $s$, lifts uniquely to a map on process terms, $\widehat{s} :
\Proc \rightarrow \Proc$ by the following equations.

\begin{eqnarray*}
(0) \psubstp{Q}{P}         & \defneqls &    0 \\
(R \juxtap S) \psubstp{Q}{P}
		& \defneqls &    
		(R)\psubstp{Q}{P} \juxtap (S) \psubstp{Q}{P} \\
({x}{?}{( y_1, \ldots, y_N )} \Rightarrow R) \psubstp{Q}{P}    
		& \defneqls &    
		{(x)}\substp{Q}{P}{?}{( z_1, \ldots, z_N )}\Rightarrow (R \psubstn{z_1}{y_1}\ldots\psubstn{z_N}{y_N}) \psubstp{Q}{P} \\
%(x\id{[}y\id{]}) \psubstp{Q}{P}
%		& \defneqls &    
%		(x)\substp{Q}{P} \id{[}(y)\substp{Q}{P} \id{]} \\
({x}{!}{(}{R}{)}) \psubstp{Q}{P}  
 		& \defneqls &
 		{(x)\substp{Q}{P}}{!}{(}{ R \psubstp{Q}{P} }{)} \\
({*}{x})  \psubstp{Q}{P}       
		& \defneqls & 
		\left\{ 
			\begin{array}{ccc} 
				\dropn{\quotep{Q}} & & x \nameeq \quotep{P} \\
                              	\dropn{x} & & otherwise \\
			\end{array}
		\right.
\end{eqnarray*}
 

where

\begin{equation*}
(x){\{} {@}Q / {@}P {\}}            \defneqls 
		\left\{ 
			\begin{array}{ccc}
				{@}Q & & x \nameeq {@}P \\
                                x & & otherwise \\
			\end{array}
		\right.
\end{equation*}

and $z_i$ is chosen distinct from $\quotep{P}$, $\quotep{Q}$, the free
names in $Q$, and all the names in $R$ in the equation for input. Our
$\alpha$-equivalence will be built in the standard way from this
substitution.

\subsection{ Dynamic quote: an example }

Anticipating something of what's to come, consider applying the
substitution, $\widehat{{\{}u / z {\}}}$, to the following pair
of processes, ${w}{!}{(}{y}{!}{(}{*}{z}{)}{)}$ and ${w}{!}{(}{*}{@}({y}{!}{(}{*z}{)}{)}{)}$.

\begin{eqnarray*}
	{w}{!}{(}{y}{!}{(}{*}{z}{)}{)}\widehat{{\{}u / z{\}}}
		& = &
		{w}{!}{(}{y}{!}{(}{*}u{)}{)} \\
       {w}{!}{(}{*}{@}({y}{!}{(}{*z}{)}{)}{)}\widehat{{\{}u / z{\}} }
		& = &
		{w}{!}{(}{*}{@}({y}{!}{(}{*z}{)}{)}{)}
\end{eqnarray*}

Because the body of the referenced process is impervious to
substitution, we get radically different answers. In fact, by
examining the first process in an input context, e.g. $x{(}{z}{)}
\Rightarrow {w}{!}{(}{y}{!}{(}{*}{z}{)}{)}$, we see that combinations
of reference and dereference may be shaped by prefixed inputs binding
dereferenced names. In this sense, these operators provide a means to
dynamically construct processes before reifying them as names,
functioning much like quasiquote in {\tt Lisp}.

\subsection{Semantic substitution}

The substitution used in $\alpha$-equivalence is really only a device
to formally recognize that binding occurrences do not depend on the
specific names. Semantic subsitution, the engine of computation in
this calculus, differs from syntactic substitution in its application
to a dropped name.

\begin{eqnarray*}
(\dropn{x})  \psubstp{Q}{P}       
		& \defneqls & 
		\left\{ 
			\begin{array}{ccc} 
				Q & & x \nameeq \quotep{P} \\
                              	\dropn{x} & & otherwise \\
			\end{array}
		\right.
\end{eqnarray*}

In the remainder of the paper we will refer to semantic and syntactic
substitutions simply as substitutions and rely on context to
distinguish which is meant. Similarly, we will abuse notation and
write $\substn{y}{x}$ for $\psubstn{y}{x}$.

Finally equipped with these standard features we can present the
dynamics of the calculus.

\subsection{Operational Semantics}
The reduction rules for {\rhoc}  are
% \infrule[Comm]
% { {{x}_0 \nameeq {x}_3} }
% {{{{x}_{0}\id{[}{x}_{2}\id{]}}} \juxtap {{x}_{3}\id{(}{x}_{1}\id{)} \concat {P}}
% \red {P}\id{\{}{x}_{2} \id{/} {x}_{1} \id{\}}}

%\infrule[Comm]
%{ {x}_{0} \nameeq {x}_{1} }
%{{{ x_{0} \id{[} z \id{]}}} \juxtap { x_{1} \id{(} y \id{)} \concat {P}}
%\red {P}\id{\{} z \id{/} y \id{\}}}

\infrule[Comm]
{ {x}_{0} \nameeq {x}_{1} }
{{{ x_{0}{?}{(}{y_1},\ldots,{y_N}{)} \concat {P}}\juxtap {x_{1}}{!}{(}{Q_1},\ldots,{Q_N}{)}}
\red {{P}{\{}\quotep{Q_1}{/}{y_1},\ldots,\quotep{Q_N}{/}{y_N}{\}}}}

In addition, we have the following context rules:

\infrule[Par]{{P} \red {P}'}{{{P} \juxtap {Q}} \red {{P}' \juxtap {Q}}}

\infrule[Equiv]{{{P} \scong {P}'} \andalso {{P}' \red {Q}'} \andalso {{Q}' \scong {Q}}}{{P} \red {Q}}

The context rules are entirely standard and we do not say much about
them here. The communication rule makes it possible for agents to
synchronize at name-equivalent guards and communicate processes
packaged as names. Here is a simple example of the use of quasiquote:

\begin{eqnarray*}
	x{(}{z}{)} \Rightarrow {w}{!}{(}{y}{!}{(}{*}{z}{)}{)} \juxtap x{!}{(}{P}{)} & \red & {w}{!}{(}{y}{!}{(}P{)}{)} \\
\end{eqnarray*}

\paragraph{Bisimulation}

One of the central features of process calculi, referred to in the
literature as bisimulation, is an effective notion of
substitutability, i.e. when one process can be substituted for
another, and with it a range of powerful proof techniques. For this
paper we focus principally on the use of logic to interpret policy and
so move a discussion of bisimulation to an appendix. The main theorem
of the next section relates the logic to bisimulation. The reader
unfamiliar with this important aspect of programming language
semantics is strongly encouraged to look at
\cite{DBLP:LNCS/Sangiorgi06}.

\section{Logic}
Namespace logic resides in the subfamily of Hennessy-Milner logics
discovered by Caires and Cardelli known as spatial logics
\cite{DBLP:conf/fossacs/Caires04}. Thus, as is seen below, in addition
to the action modalities, we also find formulae for \emph{separation}
corresponding, at the logical level, to the structural content of the
parallel operator at the level of the calculus. Likewise, we have
quantification over names. There are important differences between the
logic presented here and Caires' logic. The interested reader is
referred to \cite{DBLP:conf/tgc/MeredithR05}.

% In this connection, however, we find an interesting difference between
% spatial logics investigated heretofore and this one. As in the
% calculus, we find no need for a type operator corresponding to the $\nu$
% construction. However, revelation in spatial logic is a structural
% notion \cite{DBLP:conf/fossacs/Caires04}. It detects the
% \emph{declaration} of a new name. No such information is available in
% the reflective calculus or in namespace logic. The calculus and the
% logic can arrange that names are used in a manner consistent with
% their being declared as new in the {\pic}, but it cannot detect the
% declaration itself. Seen from this perspective, revelation is a
% somewhat remarkable observation, as it seems to be about detecting the
% programmer's intent.

\subsection{Examples}

A principal advantage to using logical formulae, aka types, of this
kind is that they denote classes or programs. Unlike the usual notion
of type, where a types inhabitants are instances of data structures,
in namespace logic a formulae (i.e. a type) $\phi$ is inhabited by
programs -- namely all the programs that satisfy the
formulae. Namespace logic takes this a step further. Because it is
built on a reflective programming language (the \rhoc) it also has
formulae, $\pquotep{\phi}$, for describing classes of names. Said
another way, the inhabitants of types of the form $\pquotep{\phi}$ are
names and hence these types have the right to be called
namespaces. The next two examples show how useful namespaces are in
the security setting.

\subsubsection{Controlling access to namespaces}
\label{namespace}
Suppose that $\pquotep{\phi}$ describes some namespace, {\em i.e.} some
collection of names. We can insist that a process restrict its next
input to names in that namespace by insisting that it witness the formula

\begin{eqnarray}
  \pprefix{\pquotep{\phi}}{b}{\ptrue} \& \neg \pprefix{\pquotep{\neg \phi}}{b}{\ptrue} \nonumber
\end{eqnarray}

\noindent which simply says the the process is currently able to take input from
a name in the namespace $\pquotep{\phi}$ and is not capable of input on
any name not in that namespace. In a similar manner, we can limit a
server to serving only inputs in $\pquotep{\phi}$ throughout the
lifetime of its behavior \footnote{Of course, this formula also says
the server never goes down, either---or at least is always willing
to take such input.}

\begin{eqnarray}
  \pgfp{X}{\pprefix{\pquotep{\phi}}{b}{X} \& \neg \pprefix{\pquotep{\neg \phi}}{b}{X}} \nonumber
\end{eqnarray} 

This formula is reminiscent of the functionality of a firewall, except
that it is a \emph{static} check. A process witnessing this formula
will behave as though it were behind a firewall admitting only access
to the ports in $\pquotep{\phi}$ without the need for the additional
overhead of the watchdog machinery.

\begin{grammar}
\mbox{reflective logic}	& {\phi, \psi}	& \bc	& \ptrue & \mbox{verity} \\
				&					& \bm	& \pzero & \mbox{nullity} \\
				&					& \bm	& \neg \phi & \mbox{negation} \\
				&					& \bm	& \phi \& \psi & \mbox{conjunction} \\
				&					& \bm	& \phi \juxtap \psi & \mbox{separation} \\
				&					& \bm	& \pdropf{b} & \mbox{descent} \\
				&					& \bm	& \plift{a}{\phi} & \mbox{elevation} \\
				&					& \bm	& \pprefix{a}{b}{\phi} & \mbox{activity} \\
                                &					& \bm	& \pgfp{X}{\phi} & \mbox{greatest fix point} \\
                                &					& \bm	& \pquant{n}{\psi}{\phi} & \mbox{quantification} \\
				& {a}  		& \bc	& \pquotep{\phi} & \mbox{indication} \\
				&					& \bm	& b & \mbox{...} \\
				& {b}  		& \bc	& \pquotep{P} & \mbox{nomination} \\
                                &					& \bm	& n & \mbox{...} \\
\end{grammar}

We let $\PFormula$ denote the set of formulae generated by the
$\phi$-production, $\QFormula$ denote the set of formulae generated by
the $a$-production and $\PropVar$ denote the set of propositional
variables used in the $\textsf{rec}$ production.

% The satisfaction relation, $\models \subseteq \Proc \times \Formula$, between processes and formulae is given by

% \begin{eqnarray}
% 	P & \models & \ptrue \nonumber \\ 
%     P & \models & \pzero \riff P \scong \pzero \nonumber \\ 
%     P & \models & \neg \phi \riff P \not\models \phi \nonumber\\
%     P & \models & \phi \& \psi \riff P \models \phi \; \& P \; \models \psi \nonumber\\
%     P & \models & \binpar{\phi}{\psi} \riff \exists P_0, P_1.P \scong \binpar{P_0}{P_1}
%       \; \& \; P_0 \models \phi \; \& \;  P_1 \models \psi \nonumber\\
%     P & \models & \pdropf{b} \riff \exists Q, P'.P \scong \binpar{Q}{\dropn{x}}
% 	    \; \& \; x \models b \nonumber\\	
% 	P & \models & \plift{a}{\phi} \riff \exists Q, P'.P \scong \binpar{Q}{\lift{x}{P'}} 
% 		\; \& \; x \models a 
% 		\; \& \; P' \models \phi \nonumber\\
% 	P & \models & \pprefix{a}{b}{\phi} \riff \exists Q, P'.P \scong \binpar{Q}{\prefix{x}{y}{P'}} \nonumber\\
% 	  & & x \models a \nonumber\\
% 	  & & \forall c . \exists z . {P'}\substn{z}{y} \models {\phi}\substn{c}{b} \nonumber\\
%     \quotep{P} & \models & \quotep{\phi} \riff P \models \phi \nonumber\\
%     \quotep{P} & \models & \quotep{Q} \riff \quotep{P} \nameeq \quotep{Q} \nonumber
% \end{eqnarray}

Inspired by Caires' presentation of spatial logic
\cite{DBLP:conf/fossacs/Caires04}, we give the semantics in terms of
sets of processes (and names). We need the notion of a valuation $v :
\PropVar \to \wp(\Proc)$, and use the notation $v\substn{\mathcal{S}}{X}$ to mean 

\begin{eqnarray}
  v\substn{\mathcal{S}}{X}(Y) & = &
  \left\{ \begin{array}{ccc}
      S & & Y = X \\
      v(Y) & & otherwise \\
    \end{array}
  \right.\nonumber
\end{eqnarray}

The meaning of formulae is given in terms of two mutually recursive functions,

\begin{eqnarray}
\pmeaningof{ - }( - ) : \PFormula \times [\PropVar \to \wp(\Proc)] \to \wp(\Proc) \nonumber\\
\nmeaningof{ - }( - ) : \QFormula \times [\PropVar \to \wp(\Proc)] \to \wp(\QProc) \nonumber
\end{eqnarray}

\noindent taking a formula of the appropriate type and a valuation, and
returning a set of processes or a set of names, respectively.

\begin{eqnarray}
  \pmeaningof{\ptrue}(v) & = & \Proc \nonumber \\ 
  \pmeaningof{\pzero}(v) & = & \{ P : P \scong \pzero \} \nonumber \\ 
  \pmeaningof{\neg \phi}(v) & = & \Proc / \pmeaningof{\phi}(v) \nonumber\\
  \pmeaningof{\phi \& \psi}(v) & = & \pmeaningof{\phi}(v) \cap \pmeaningof{\psi}(v) \nonumber\\
  \pmeaningof{\binpar{\phi}{\psi}}(v) & = &
  \{ P : \exists P_0, P_1.P \scong \binpar{P_0}{P_1}, \; P_0 \in \pmeaningof{\phi}(v), \;  P_1 \in \pmeaningof{\psi}(v) \} \nonumber\\
  \pmeaningof{\pdropf{b}}(v) & = & \{ P : \exists x.P \scong {\dropn{x}}, \; x \in \nmeaningof{b}(v) \} \nonumber\\	
  \pmeaningof{\plift{a}{\phi}}(v) & = & \{ P : \exists P'.P \scong {\lift{x}{P'}},
                                           \; x \in \nmeaningof{a}(v), 
                                           \; P' \in \pmeaningof{\phi}(v) \} \nonumber\\
  \pmeaningof{\pprefix{a}{b}{\phi}}(v) & = & \{ P : \exists P'.P \scong {\prefix{x}{y}{P'}}, x \in \nmeaningof{a}(v), \nonumber\\
                                   &   &            \; \; \; \forall c . \exists z . {P'}\substn{z}{y} \in \pmeaningof{{\phi}\substn{c}{b}}(v) \} \nonumber\\
  \pmeaningof{\pgfp{X}{\phi}}(v) & = & \cup \{ \mathcal{S} \subseteq \Proc : \mathcal{S} \subseteq \pmeaningof{\phi}(v\substn{\mathcal{S}}{X})\} \nonumber\\
  \pmeaningof{\pquant{n}{\psi}{\phi}}(v) & = & \cap_{x \in \nmeaningof{\quotep{\psi}}(v)} \pmeaningof{{\phi}\substn{x}{n}}(v) \nonumber\\
  \nmeaningof{\pquotep{\phi}}(v) & = & \{ x : x \nameeq \quotep{P}, P \in \pmeaningof{\phi}(v) \} \nonumber\\
  \nmeaningof{\pquotep{P}}(v) & = & \{ x : x \nameeq  \quotep{P} \} \nonumber
\end{eqnarray}

We say $P$ witnesses $\phi$ (resp., $x$ witnesses $\pquotep{\phi}$),
written $P \models \phi$ (resp., $x \models \pquotep{\phi}$) just when
$\forall v . P \in \meaningof{\phi}(v)$ (resp., $\forall v . x \in \meaningof{\pquotep{\phi}}(v)$).

\begin{thm}[Equivalence]
	$P \wbbisim Q \riff \forall \phi . P \models \phi \riff Q \models \phi .$
\end{thm}

The proof employs an adaptation of the standard strategy. As noted in
the introduction, this theorem means that there is no algorithm
guaranteeing that a check for the witness relation will terminate.

\subsubsection{Syntactic sugar }

In the examples below, we freely employ the usual DeMorgan-based
syntactic sugar. For example,

\begin{eqnarray}
	\phi \Rightarrow \psi & \defneqls & \neg ( \phi \& \neg \psi ) \nonumber\\
	\phi \vee \psi & \defneqls & \neg ( \neg \phi \& \neg \psi ) \nonumber
\end{eqnarray}

Also, when quantification ranges over all of $\QProc$, as in
$\pquant{n}{\quotep{\ptrue}}{\phi}$, we omit the typing for the
quantification variable, writing $\pquantuntyped{n}{\phi}$.

\section{Interpreting object-capabilities in \rhoc}

Rather than giving a translation of the whole of {\tt JavaScript} into
\rhoc, we focus on one example from
\cite{Drossopoulou:2013:NCP:2489804.2489811} designed to illustrate
key aspects of object-capabilities and requirements for a policy
language.

\begin{verbatim}
var makeMint = () => {
  var m = WeakMap();
  var makePurse = () => mint(0);
  var mint = balance => {
    var purse = def({
      getBalance: () => balance,
      makePurse: makePurse,
      deposit: (amount, srcP) => Q(srcP).then(src => {
        Nat(balance + amount);
        m.get(src)(Nat(amount));
        balance += amount;
      })
    });
    var decr = amount => {
      balance = Nat(balance - amount);
    };
    m.set(purse, decr);
    return purse;
  };
  return mint;
};
\end{verbatim}

Interpreting this code illustrates how surprisingly intuitive and
natural it is to represent and reason about object-capabilities in
\rhoc. Essentially, a capability---{\em i.e.} access to some behavior, power
or authority---is represented by a channel. When an agent in the \rhoc
has access to a channel it has exactly that: access to some behavior,
power or authority.

% Can we get away with describing the difference between WeakMap and Map just in English?

Armed with the two gadgets above, we can translate each of the language elements from the bank example into \rhoc.

\begin{eqnarray*}
 \meaningof{\texttt{var}\; x}( k ) & \defneqls & \binpar{Cell( x, \texttt{undefined} )}{k!()} \\
 \meaningof{\texttt{var}\; x = v}( k ) & \defneqls & Cell( x, \meaningof{ v }( k ) ) \\
 \meaningof{ P ; Q }( k ) & \defneqls & \texttt{new}(k_1)\{ \binpar{\meaningof{ P }( k_1 )}{ k_1?() => \meaningof{ Q }( k )} \} \\
 \meaningof{ \texttt{i} +\!= \texttt{a} ; P }( k ) & \defneqls & \texttt{new} \{ \binpar{\binpar{\texttt{i} ! get( r )}{r?( v ) \Rightarrow \texttt{i}! set( v + \texttt{a} ) }}{\meaningof{P}( k )} \}\\
\end{eqnarray*}

% \begin{verbatim}
% {
%   new( rslt ){
%     balance ! get( rslt )
%     rslt?( b ) => {
%       balance ! set( b + amount )
%     }
%   } 
%   [| P |] 
% }
% \end{verbatim}

% We need to address the translation of promises. We need to address the translation of Nat( … ).

The key point is that the translation is compositional and therefore
we can reason equationally in the translated code. For example, to
translate the code fragment 
\[\meaningof{ \mbox{\tt var}\; balance = initAmt; balance\; +\!= \; amount; P }( k )\]
we calculate directly

% K[X] := var balance = initAmt; X

% [| K[balance += amount; P] |]
% =
% [| var balance = initAmt; balance += amount; P |]
% = 
% { 
%   Cell( balance, initAmt ) 
%   k!() 
%   [| balance += amount; P |]
% }
% =
\begin{lstlisting}[mathescape]
{ 
  $Cell( balance, initAmt )$
  $k!()$
  {
    new $( rslt, k_1 )$ {
      $balance ! get( rslt )$  
       $rslt?( b ) \Rightarrow$ {
        $balance ! set( b + amount )$
        $k1$
      }
    } 
    $k_1?() \Rightarrow \meaningof{ P }( k )$
  }
}
\end{lstlisting}


\section{Interpreting policy}

Drossopoulou \cite{Drossopoulou:2013:NCP:2489804.2489811} argues for several different types of policy
specifications. In this paper we focus on deniability policies, since the
others have ready translations in this setting. Deniability is the one
type of policy specification where the translation is not at all
straightforward. For the reader familiar with logics of concurrency the
core idea is to use rely-guarantee combined with the adjunct to
spatial separation.

A visual inspection of the code for $Cell$ reveals that if a
process $P$’s names are fresh wrt to $slot$, then $P$ cannot
directly affect any $Cell( slot, state )$. Unfortunately, 
visual inspection is not reliable in settings only mildly more 
complex, as in the bank example above; Yee showed that a 90-man-hour
review of around a hundred lines of heavily commented Python code 
by security specialists was not sufficient to discover three 
inserted bugs \cite[Section 7]{Pvote}. 
However, we can use our logic to state and verify the fact that $P$
cannot affect any {\tt Cell}. Adapting the firewall formula we have

$Cell (slot, state) \models 
\pgfp{X}{\pprefix{\pquotep{slot}}{b}{X} \& 
\neg \pprefix{\pquotep{\neg slot}}{b}{X}}$

If we have that $P \models \pgfp{X}{\neg
  \pprefix{\pquotep{slot}}{b}{X}}, \;$ then
$\; \forall \; state . \mbox{\tt new}(slot)\mbox{\tt \{}
\binpar{P}{Cell(slot, state)} \mbox{\tt \}}\wbbisim 0$

More generally, note that objects involve not just one cell, but
many. By restricting those cells to slots that live in namespace $Slot
\defneqls {@}\phi$ for some $\phi$ we can scale our formula to
separate objects from a given environment. We'll say more about this
in the conclusions. 

For now we refine the basic idea to build up to modeling the bank
example. The central intuition is that the purse is essentially a
cell. In the paragraphs above we witnessed a basic form of argumentation: if $Q
\models \phi$ then when $P \models \psi$ we have that
$\texttt{new}(x_1,\ldots,x_N)\binpar{P}{Q} \wbbisim S$ for some properties
$\phi$ and $\psi$ and some behavior, $S$. This shape turns out to be
very close to the use of rely-guarantee identified by Honda in
\cite{Honda:2008:UTP:2227536.2227558}.

\section{Conclusions and future work}

We looked at policy as types.

Dependent types are future work.

\paragraph{Acknowledgments.}
The authors wish to thank Mark Miller, Sophia Drossopoulou and James Nolan for
thoughtful and stimulating conversation about policy, object
capabilities and types.

% ------------------------------------------------------------------------
%GATHER{Xbib.bib}   % For Gather Purpose Only
%GATHER{Paper.bbl}  % For Gather Purpose Only
\bibliographystyle{amsplain}
\bibliography{tocappi}

% ------------------------------------------------------------------------

\section{Appendix: $\rho$ sugar}

It is known that replication (and hence recursion) can be implemented
in a higher-order process algebra \cite{SangiorgiWalker}. This
encoding provides a good example of calculation with the {\rhoc}.

% \begin{equation*}
% !P \defneqls \lift{x}{(x\id{(}y\id{)}\concat(\rpquote y\lpquote \juxtap x\id{[}y\id{]}) \juxtap P)} \juxtap x\id{(}z\id{)}\concat(\rpquote z\lpquote \juxtap x\id{[}z\id{]})
% \end{equation*}

\begin{eqnarray*}
	D(x) & \defneqls & \prefix{x}{y}{(\binpar{\outputp{x}{y}}{\dropn{y}})} \\
	\xbangp{P}{x} & \defneqls & \binpar{\lift{x}{\binpar{D(x)}{P}}}{D(x)}
\end{eqnarray*}

\begin{eqnarray*}
	\xbangp{P}{x} & & \\
	=
	& \lift{x}{(\prefix{x}{y}{(\outputp{x}{y} \juxtap \dropn{y})) \juxtap P}} 
	      \juxtap \prefix{x}{y}{(\outputp{x}{y} \juxtap \dropn{y})} & \\
%	\red
%	& \outputp{x}{\quotep{(\prefix{x}{y}{(\outputp{x}{y} \juxtap \dropn{y})) \juxtap P}}}
%	  \juxtap \prefix{x}{y}{(\outputp{x}{y} \juxtap \dropn{y})} & \\
	\red
	& (\outputp{x}{y} \juxtap \dropn{y})\substn{\quotep{(\prefix{x}{y}{(\dropn{y} \juxtap \outputp{x}{y})) \juxtap P}}}{y} & \\
	=
	& \outputp{x}{\quotep{(\prefix{x}{y}{(\outputp{x}{y} \juxtap \dropn{y})) \juxtap P}}}
	  \juxtap {(\prefix{x}{y}{(\outputp{x}{y} \juxtap \dropn{y})) \juxtap P}} & \\
	\red
	& \ldots & \\
	\red^*
	& P \juxtap P \juxtap \ldots & \\
\end{eqnarray*}

Of course, this encoding, as an implementation, runs away, unfolding
$\xbangp{P}{x}$ eagerly. A lazier and more implementable replication
operator, restricted to input-guarded processes, may be obtained as follows.

\begin{equation*}
\bangxp{\prefix{u}{v}{P}}{x}
	\defneqls 
	\binpar{\lift{x}{\prefix{u}{v}{(\binpar{D(x)}{P})}}}{D(x)}
\end{equation*}

It is worth noting that the combination of reference and dereference
operators is essential to get computational completeness. 

Armed with this we can consider a conservative extension of the
calculus presented above.

\begin{grammar}
\mbox{\rhoc-extended}		& { P, Q }              & \bc			& \ldots & \mbox{previous syntax} \\
				&                        		& \bm	& (\texttt{def} {X}{( y_1, \ldots, y_N )} \Rightarrow {P}){( Q_1, \ldots, Q_N )}& \mbox{definition} \\ 
				&					& \bm	& {X}{( Q_1, \ldots, Q_N )} & \mbox{invocation} \\
				&					& \bm	& \texttt{new}( x_1, \ldots, x_N )P & \mbox{allocation} \\
\end{grammar}

The notation for recursive definitions is slightly quirky in that it
simultaneously defines and invokes the definition to some arguments --
in order to make the recursive form be a process expression, as
opposed to a separate category of declaration. Comparing this with the
examples above we have simply omitted the application of the recursive
definitions to initial arguments in the interest of brevity.

\begin{eqnarray*}
  (\texttt{def} {X}{( y_1, \ldots, y_N )} \Rightarrow {P}){( Q_1, \ldots, Q_N )} & \defneqls & \binpar{\bangxp{(n( X, P ) \Rightarrow P')}{n( X, P )}}{n( X, P )!( Q_1, \ldots, Q_N )} \\  
\end{eqnarray*}

where $P' \defneqls P \{ n( X, P )!( Q_1, \ldots, Q_N )/ X( Q_1,
\ldots, Q_N )\}$, i.e., the body of $P$ in which every occurrence of
$X( Q_1, \ldots, Q_N )$ is replaced with $n( X, P )!( Q_1, \ldots, Q_N
)$, and $n( X, P )$ generates a name from $X$ guaranteed fresh in $P$.

Likewise, there are several translation of the \pic\; $\texttt{new}$
operator into the \rhoc. Rather than take up space in this paper we
simply refer the reader to \cite{DBLP:journals/entcs/MeredithR05}, or
better yet, invite them to come up with a definition to test their
understanding of the calculus.

Additionally, we call out input-guarded only summations using the notation

$\texttt{match}\{ x_1?( y_{1,1}, \ldots, y_{1,N} ) \Rightarrow P_1 ; \ldots ; x_M?(y_{M,1}, \ldots, y_{M,N'} ) \Rightarrow P_M \}$ 

instead of 

$x_1?( y_{1,1}, \ldots, y_{1,N} ) \Rightarrow P_1 + \ldots + x_M?( y_{M,1},\ldots, y_{M,N'} ) \Rightarrow P_M$

In a \texttt{match} context we avail ourselves of a pattern-matching
syntax, such as $x ? get( ret ) => ret!( v )$ and $x ! get( k )$.

Finally, we use $\{ \ldots \}$ for grouping expressions and in more complex examples, omit
$\binpar{}{}$ in favor of line breaks for legibility. Thus, an expression for a classic race-condition $\binpar{ x?( y_1, \ldots, y_N ) \Rightarrow P}{\binpar{x!( Q_1, \ldots, Q_N )}{ x?( z_1, \ldots, z_N ) \Rightarrow R}}$ might be written
\begin{lstlisting}
  {
    x?( y1, ... , yN ) => P
    x!( Q1, ... , QN )
    x?( z1, ... , zN ) => R
  }
\end{lstlisting}

\section{Appendix: bisimulation}

Having taken the notion of restriction out of the language, we
carefully place it back into the notion of observation, and hence into
the notion of program equality, {\em i.e.} bisimulation. That is, we
parameterize the notion of barbed bisimulation by a set of names over
which we are allowed to set the barbs. The motivation for this choice
is really comparison with other calculi. The set of names of the
{\rhoc} is \textit{global}. It is impossible, in the grammar of
processes, to guard terms from being placed into contexts that can
potentially observe communication, so we provide a place for
reasoning about such limitations on the scope of observation in the
theory of bisimulation.

From an ocap perspective, having the ability to enumerate names is
usually a sign that a language is not even memory-safe, let alone
capability-safe.  However, in Section \ref{namespace} below, we show
that we can use types to create namespaces and then statically prove
which namespaces a process has access to.

% [Ed. note: suppose c is not in a barb set, can we make hidden links in
% programs? Does this screw up the notion of a parameterized barbed
% bisimulation?]
%will become clearer when we treat the encoding of the asynchronous {\pic}.

\begin{defn}
An \emph{observation relation}, $\downarrow_{\mathcal N}$, over a set
of names, $\mathcal N$, is the smallest relation satisfying the rules
below.

\infrule[Out-barb]{y \in {\mathcal N}, \; x \nameeq y}
		  {\outputp{x}{v} \downarrow_{\mathcal N} x}
\infrule[Par-barb]{\mbox{$P\downarrow_{\mathcal N} x$ or $Q\downarrow_{\mathcal N} x$}}
		  {\binpar{P}{Q} \downarrow_{\mathcal N} x}

We write $P \Downarrow_{\mathcal N} x$ if there is $Q$ such that 
$P \wred Q$ and $Q \downarrow_{\mathcal N} x$.
\end{defn}

Notice that $\prefix{x}{y}{P}$ has no barb.  Indeed, in {\rhoc} as well
as other asynchronous calculi, an observer has no direct means to
detect if a sent message has been received or not.

\begin{defn}
%\label{def.bbisim}
An  ${\mathcal N}$-\emph{barbed bisimulation} over a set of names, ${\mathcal N}$, is a symmetric binary relation 
${\mathcal S}_{\mathcal N}$ between agents such that $P\rel{S}_{\mathcal N}Q$ implies:
\begin{enumerate}
\item If $P \red P'$ then $Q \wred Q'$ and $P'\rel{S}_{\mathcal N} Q'$.
\item If $P\downarrow_{\mathcal N} x$, then $Q\Downarrow_{\mathcal N} x$.
\end{enumerate}
$P$ is ${\mathcal N}$-barbed bisimilar to $Q$, written
$P \wbbisim_{\mathcal N} Q$, if $P \rel{S}_{\mathcal N} Q$ for some ${\mathcal N}$-barbed bisimulation ${\mathcal S}_{\mathcal N}$.
\end{defn}

% \emph{Barbed congruence}, written $\fwbeq_{\mathcal N}$, is the largest
% ${\mathcal N}$-barbed bisimulation which is also a congruence.
% \end{defn}

% \begin{rem}
% 	Asking for congruence including contexts of the form
% 	$\lift{x}{\diamond}$ requires that $P \wbbisim Q$ implies that
% 	$\quotep{P} \nameeq \quotep{Q}$. This is too
% 	stringent. Instead we seek a weaker form of equivalence,
% 	closed only up to substitions.
% \end{rem}

% \begin{defn}
% $P$ is \emph{barbed equivalent} to $Q$, written $P \wbeq Q$, if and only if $P \sigma \parop R \wbbisim Q \sigma 
% \parop R$, for every $R$ and substitution $\sigma$.
% \end{defn}

% It is well-known that, due to the universal quantification over
% contexts, barbed congruence is hard to demonstrate.  A standard remedy
% mitigating this difficulty is the context lemma below.

% \begin{lem}
% %\label{contextlemma}
% $P \wbeq Q$ if and only if $P \sigma \parop R \wbbisim Q \sigma 
% \parop R$, for every $R$ and substitution $\sigma$.
% \end{lem}
% This lemma replaces the quantification over contexts 
% with a quantification over parallel contexts and substitutions, which
% is still hard to verify. 

% ------------------------------------------------------------------------

\end{document}
% ------------------------------------------------------------------------
